// Core vulnerability types
export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low' | 'Info';
  category: 'Security' | 'Gas' | 'Logic' | 'Compliance' | 'Best Practice';
  cweId?: string; // Common Weakness Enumeration ID
  line?: number;
  column?: number;
  sourceCode?: string;
  recommendation: string;
  references?: string[];
  confidence: 'High' | 'Medium' | 'Low';
  impact: string;
  exploitability: string;
}

// Gas optimization suggestions
export interface GasOptimization {
  id: string;
  title: string;
  description: string;
  currentGas: number;
  optimizedGas: number;
  savings: number;
  savingsPercentage: number;
  line?: number;
  codeExample?: {
    before: string;
    after: string;
  };
  difficulty: 'Easy' | 'Medium' | 'Hard';
}

// Compliance check results
export interface ComplianceResult {
  standard: string; // e.g., 'ERC-20', 'ERC-721', 'ERC-1155'
  status: 'Compliant' | 'Non-Compliant' | 'Partially Compliant' | 'Not Applicable';
  issues: string[];
  recommendations: string[];
  score: number; // 0-100
}

// Contract metadata
export interface ContractMetadata {
  address: string;
  name?: string;
  symbol?: string;
  decimals?: number;
  totalSupply?: string;
  owner?: string;
  isProxy: boolean;
  implementationAddress?: string;
  compiler: {
    version: string;
    optimization: boolean;
    runs?: number;
  };
  sourceCode?: string;
  abi?: any[];
  creationTransaction?: string;
  creationBlock?: number;
  verificationStatus: 'Verified' | 'Unverified' | 'Partially Verified';
}

// Network information
export interface NetworkInfo {
  id: string;
  name: string;
  chainId: number;
  rpcUrl: string;
  explorerUrl?: string;
  nativeCurrency: {
    name: string;
    symbol: string;
    decimals: number;
  };
}

// Scan request
export interface ScanRequest {
  contractAddress: string;
  networkId: string;
  scanType: 'quick' | 'standard' | 'deep';
  includeGasOptimization: boolean;
  includeComplianceCheck: boolean;
  customRules?: string[];
  sourceCode?: string; // Optional: if user provides source code
}

// Scan status
export type ScanStatus = 
  | 'idle' 
  | 'initializing' 
  | 'fetching-contract' 
  | 'analyzing-bytecode' 
  | 'checking-vulnerabilities' 
  | 'optimizing-gas' 
  | 'checking-compliance' 
  | 'generating-report' 
  | 'completed' 
  | 'failed' 
  | 'cancelled';

// Main scan result
export interface VulnerabilityScanResult {
  scanId: string;
  contractAddress: string;
  networkId: string;
  scanType: 'quick' | 'standard' | 'deep';
  timestamp: string;
  duration: number; // in milliseconds
  
  // Contract information
  contractMetadata: ContractMetadata;
  networkInfo: NetworkInfo;
  
  // Analysis results
  vulnerabilities: Vulnerability[];
  gasOptimizations: GasOptimization[];
  complianceResults: ComplianceResult[];
  
  // Summary
  summary: {
    overallRisk: 'Critical' | 'High' | 'Medium' | 'Low';
    riskScore: number; // 0-100
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    infoCount: number;
    gasOptimizationSavings: number;
    complianceScore: number;
  };
  
  // Additional metadata
  scannerVersion: string;
  rulesVersion: string;
  confidence: number; // Overall confidence in results
  recommendations: string[];
}

// API response types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  metadata?: {
    requestId: string;
    timestamp: string;
    version: string;
  };
}

// Scan progress callback
export type ScanProgressCallback = (progress: number, status: ScanStatus, message?: string) => void;

// Export formats
export type ExportFormat = 'json' | 'pdf' | 'csv' | 'html';

// Scan history item
export interface ScanHistoryItem {
  scanId: string;
  contractAddress: string;
  networkId: string;
  timestamp: string;
  overallRisk: string;
  vulnerabilityCount: number;
  status: 'completed' | 'failed' | 'cancelled';
}

// Rate limiting
export interface RateLimitInfo {
  limit: number;
  remaining: number;
  resetTime: number;
  retryAfter?: number;
}

// Authentication
export interface AuthToken {
  token: string;
  expiresAt: number;
  refreshToken?: string;
  scope: string[];
}

// Error types
export class VulnerabilityError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode?: number,
    public details?: any
  ) {
    super(message);
    this.name = 'VulnerabilityError';
  }
}

export class NetworkError extends VulnerabilityError {
  constructor(message: string, details?: any) {
    super(message, 'NETWORK_ERROR', 500, details);
    this.name = 'NetworkError';
  }
}

export class ValidationError extends VulnerabilityError {
  constructor(message: string, details?: any) {
    super(message, 'VALIDATION_ERROR', 400, details);
    this.name = 'ValidationError';
  }
}

export class RateLimitError extends VulnerabilityError {
  constructor(message: string, public rateLimitInfo: RateLimitInfo) {
    super(message, 'RATE_LIMIT_ERROR', 429, rateLimitInfo);
    this.name = 'RateLimitError';
  }
}
