import {
  ScanRequest,
  VulnerabilityScanResult,
  ScanProgressCallback,
  ExportFormat,
  ScanHistoryItem
} from '../types/vulnerability';
import { VulnerabilityService } from '../services/VulnerabilityService';
import { AuthMiddleware } from '../middleware/AuthMiddleware';
import { RateLimitMiddleware } from '../middleware/RateLimitMiddleware';
import { ValidationMiddleware, validator } from '../middleware/ValidationMiddleware';
import { ErrorHandlingMiddleware, errorHandler } from '../middleware/ErrorHandlingMiddleware';

export interface ControllerResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  metadata?: {
    requestId: string;
    timestamp: string;
    processingTime: number;
  };
}

export class VulnerabilityController {
  private vulnerabilityService: VulnerabilityService;
  private authMiddleware: AuthMiddleware;
  private rateLimitMiddleware: RateLimitMiddleware;
  private validationMiddleware: ValidationMiddleware;
  private errorHandler: ErrorHandlingMiddleware;

  constructor(
    authConfig?: any,
    rateLimitConfig?: any
  ) {
    this.vulnerabilityService = new VulnerabilityService();
    this.authMiddleware = new AuthMiddleware(authConfig || {
      tokenEndpoint: '/api/auth/token',
      refreshEndpoint: '/api/auth/refresh'
    });
    this.rateLimitMiddleware = new RateLimitMiddleware(rateLimitConfig || {
      maxRequests: 10,
      windowMs: 60000 // 1 minute
    });
    this.validationMiddleware = validator;
    this.errorHandler = errorHandler;
  }

  // Main scan endpoint
  async performScan(
    request: ScanRequest,
    progressCallback?: ScanProgressCallback,
    abortSignal?: AbortSignal
  ): Promise<ControllerResponse<VulnerabilityScanResult>> {
    const startTime = Date.now();
    const requestId = this.generateRequestId();

    try {
      // Rate limiting check
      await this.rateLimitMiddleware.checkRateLimit(request);

      // Authentication check
      const authToken = await this.authMiddleware.authenticate();
      if (!authToken) {
        throw new Error('Authentication required');
      }

      // Input validation
      const validationResult = this.validationMiddleware.validate('SCAN_REQUEST', request);
      if (!validationResult.isValid) {
        const firstError = validationResult.errors[0];
        throw firstError;
      }

      // Record successful rate limit check
      this.rateLimitMiddleware.recordRequest(true, request);

      // Perform the scan
      const result = await this.vulnerabilityService.performScan(
        request,
        abortSignal,
        progressCallback
      );

      return {
        success: true,
        data: result,
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };

    } catch (error: any) {
      // Record failed request for rate limiting
      this.rateLimitMiddleware.recordRequest(false, request);

      // Handle error through middleware
      const handledError = await this.errorHandler.handleError(error, {
        requestId,
        additionalData: { request, operation: 'performScan' }
      });

      return {
        success: false,
        error: {
          code: handledError.code,
          message: this.errorHandler.getUserFriendlyMessage(handledError),
          details: handledError.details
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };
    }
  }

  // Get scan history
  async getScanHistory(
    limit: number = 10,
    offset: number = 0
  ): Promise<ControllerResponse<ScanHistoryItem[]>> {
    const startTime = Date.now();
    const requestId = this.generateRequestId();

    try {
      // Authentication check
      await this.authMiddleware.authenticate();

      // Rate limiting
      await this.rateLimitMiddleware.checkRateLimit();

      // Get history from storage (mock implementation)
      const history = this.getMockScanHistory(limit, offset);

      this.rateLimitMiddleware.recordRequest(true);

      return {
        success: true,
        data: history,
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };

    } catch (error: any) {
      this.rateLimitMiddleware.recordRequest(false);

      const handledError = await this.errorHandler.handleError(error, {
        requestId,
        additionalData: { operation: 'getScanHistory', limit, offset }
      });

      return {
        success: false,
        error: {
          code: handledError.code,
          message: this.errorHandler.getUserFriendlyMessage(handledError)
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };
    }
  }

  // Get specific scan result
  async getScanResult(scanId: string): Promise<ControllerResponse<VulnerabilityScanResult>> {
    const startTime = Date.now();
    const requestId = this.generateRequestId();

    try {
      // Authentication check
      await this.authMiddleware.authenticate();

      // Rate limiting
      await this.rateLimitMiddleware.checkRateLimit();

      // Validation
      if (!scanId || typeof scanId !== 'string') {
        throw new Error('Valid scan ID is required');
      }

      // Get scan result from storage (mock implementation)
      const result = this.getMockScanResult(scanId);
      if (!result) {
        throw new Error('Scan result not found');
      }

      this.rateLimitMiddleware.recordRequest(true);

      return {
        success: true,
        data: result,
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };

    } catch (error: any) {
      this.rateLimitMiddleware.recordRequest(false);

      const handledError = await this.errorHandler.handleError(error, {
        requestId,
        additionalData: { operation: 'getScanResult', scanId }
      });

      return {
        success: false,
        error: {
          code: handledError.code,
          message: this.errorHandler.getUserFriendlyMessage(handledError)
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };
    }
  }

  // Export scan results
  async exportScanResult(
    scanId: string,
    format: ExportFormat
  ): Promise<ControllerResponse<{ downloadUrl: string }>> {
    const startTime = Date.now();
    const requestId = this.generateRequestId();

    try {
      // Authentication check
      await this.authMiddleware.authenticate();

      // Rate limiting
      await this.rateLimitMiddleware.checkRateLimit();

      // Validation
      const validationResult = this.validationMiddleware.validate('EXPORT_REQUEST', {
        scanId,
        format
      });
      if (!validationResult.isValid) {
        throw validationResult.errors[0];
      }

      // Get scan result
      const scanResult = this.getMockScanResult(scanId);
      if (!scanResult) {
        throw new Error('Scan result not found');
      }

      // Export the result
      await this.vulnerabilityService.exportResults(scanResult, format);

      this.rateLimitMiddleware.recordRequest(true);

      return {
        success: true,
        data: {
          downloadUrl: `#exported-${scanId}-${format}` // Mock download URL
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };

    } catch (error: any) {
      this.rateLimitMiddleware.recordRequest(false);

      const handledError = await this.errorHandler.handleError(error, {
        requestId,
        additionalData: { operation: 'exportScanResult', scanId, format }
      });

      return {
        success: false,
        error: {
          code: handledError.code,
          message: this.errorHandler.getUserFriendlyMessage(handledError)
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };
    }
  }

  // Get rate limit status
  async getRateLimitStatus(): Promise<ControllerResponse<any>> {
    const startTime = Date.now();
    const requestId = this.generateRequestId();

    try {
      const rateLimitInfo = this.rateLimitMiddleware.getRateLimitInfo();
      const stats = this.rateLimitMiddleware.getStats();

      return {
        success: true,
        data: {
          ...rateLimitInfo,
          stats
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };

    } catch (error: any) {
      const handledError = await this.errorHandler.handleError(error, {
        requestId,
        additionalData: { operation: 'getRateLimitStatus' }
      });

      return {
        success: false,
        error: {
          code: handledError.code,
          message: this.errorHandler.getUserFriendlyMessage(handledError)
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };
    }
  }

  // Health check endpoint
  async healthCheck(): Promise<ControllerResponse<any>> {
    const startTime = Date.now();
    const requestId = this.generateRequestId();

    try {
      const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        services: {
          vulnerabilityService: 'operational',
          authentication: this.authMiddleware.hasValidToken() ? 'authenticated' : 'unauthenticated',
          rateLimit: 'operational'
        },
        version: '1.0.0'
      };

      return {
        success: true,
        data: health,
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };

    } catch (error: any) {
      const handledError = await this.errorHandler.handleError(error, {
        requestId,
        additionalData: { operation: 'healthCheck' }
      });

      return {
        success: false,
        error: {
          code: handledError.code,
          message: this.errorHandler.getUserFriendlyMessage(handledError)
        },
        metadata: {
          requestId,
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime
        }
      };
    }
  }

  // Private helper methods
  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }

  private getMockScanHistory(limit: number, offset: number): ScanHistoryItem[] {
    // Mock implementation - in real app, this would query a database
    const mockHistory: ScanHistoryItem[] = [
      {
        scanId: 'scan_001',
        contractAddress: '0x1234567890123456789012345678901234567890',
        networkId: 'ethereum',
        timestamp: new Date(Date.now() - 86400000).toISOString(),
        overallRisk: 'Medium',
        vulnerabilityCount: 3,
        status: 'completed'
      },
      {
        scanId: 'scan_002',
        contractAddress: '0x0987654321098765432109876543210987654321',
        networkId: 'polygon',
        timestamp: new Date(Date.now() - 172800000).toISOString(),
        overallRisk: 'Low',
        vulnerabilityCount: 1,
        status: 'completed'
      }
    ];

    return mockHistory.slice(offset, offset + limit);
  }

  private getMockScanResult(scanId: string): VulnerabilityScanResult | null {
    // Mock implementation - in real app, this would query a database
    if (scanId === 'scan_001') {
      return {
        scanId,
        contractAddress: '0x1234567890123456789012345678901234567890',
        networkId: 'ethereum',
        scanType: 'standard',
        timestamp: new Date().toISOString(),
        duration: 45000,
        contractMetadata: {
          address: '0x1234567890123456789012345678901234567890',
          name: 'TestToken',
          symbol: 'TEST',
          isProxy: false,
          compiler: {
            version: '0.8.19',
            optimization: true,
            runs: 200
          },
          verificationStatus: 'Verified'
        },
        networkInfo: {
          id: 'ethereum',
          name: 'Ethereum Mainnet',
          chainId: 1,
          rpcUrl: 'https://mainnet.infura.io/v3/',
          nativeCurrency: {
            name: 'Ether',
            symbol: 'ETH',
            decimals: 18
          }
        },
        vulnerabilities: [],
        gasOptimizations: [],
        complianceResults: [],
        summary: {
          overallRisk: 'Medium',
          riskScore: 75,
          totalVulnerabilities: 3,
          criticalCount: 0,
          highCount: 1,
          mediumCount: 2,
          lowCount: 0,
          infoCount: 0,
          gasOptimizationSavings: 5000,
          complianceScore: 95
        },
        scannerVersion: '1.0.0',
        rulesVersion: '2024.1',
        confidence: 85,
        recommendations: []
      };
    }

    return null;
  }
}
