import {
  VulnerabilityScanResult,
  ScanRequest,
  ScanProgressCallback,
  ApiResponse,
  ContractMetadata,
  Vulnerability,
  GasOptimization,
  ComplianceResult,
  ExportFormat,
  VulnerabilityError,
  NetworkError,
  ValidationError,
  RateLimitError
} from '../types/vulnerability';
import { ApiClient } from './ApiClient';
import { ContractAnalyzer } from './ContractAnalyzer';
import { ReportGenerator } from './ReportGenerator';

export class VulnerabilityService {
  private apiClient: ApiClient;
  private contractAnalyzer: ContractAnalyzer;
  private reportGenerator: ReportGenerator;

  constructor() {
    this.apiClient = new ApiClient();
    this.contractAnalyzer = new ContractAnalyzer();
    this.reportGenerator = new ReportGenerator();
  }

  async performScan(
    request: ScanRequest,
    abortSignal?: AbortSignal,
    progressCallback?: ScanProgressCallback
  ): Promise<VulnerabilityScanResult> {
    const scanId = this.generateScanId();
    const startTime = Date.now();

    try {
      // Validate request
      this.validateScanRequest(request);
      progressCallback?.(5, 'initializing', 'Validating scan request...');

      // Check rate limits
      await this.checkRateLimit();
      progressCallback?.(10, 'initializing', 'Checking rate limits...');

      // Fetch contract metadata
      progressCallback?.(15, 'fetching-contract', 'Fetching contract information...');
      const contractMetadata = await this.fetchContractMetadata(request.contractAddress, request.networkId, abortSignal);

      // Analyze bytecode
      progressCallback?.(30, 'analyzing-bytecode', 'Analyzing contract bytecode...');
      const bytecodeAnalysis = await this.contractAnalyzer.analyzeBytecode(
        contractMetadata,
        request.networkId,
        abortSignal
      );

      // Check vulnerabilities
      progressCallback?.(50, 'checking-vulnerabilities', 'Scanning for vulnerabilities...');
      const vulnerabilities = await this.scanVulnerabilities(
        contractMetadata,
        bytecodeAnalysis,
        request.scanType,
        abortSignal
      );

      // Gas optimization analysis
      let gasOptimizations: GasOptimization[] = [];
      if (request.includeGasOptimization) {
        progressCallback?.(70, 'optimizing-gas', 'Analyzing gas optimizations...');
        gasOptimizations = await this.analyzeGasOptimizations(
          contractMetadata,
          bytecodeAnalysis,
          abortSignal
        );
      }

      // Compliance checks
      let complianceResults: ComplianceResult[] = [];
      if (request.includeComplianceCheck) {
        progressCallback?.(85, 'checking-compliance', 'Checking standard compliance...');
        complianceResults = await this.checkCompliance(
          contractMetadata,
          bytecodeAnalysis,
          abortSignal
        );
      }

      // Generate summary
      progressCallback?.(95, 'generating-report', 'Generating final report...');
      const summary = this.generateSummary(vulnerabilities, gasOptimizations, complianceResults);

      const result: VulnerabilityScanResult = {
        scanId,
        contractAddress: request.contractAddress,
        networkId: request.networkId,
        scanType: request.scanType,
        timestamp: new Date().toISOString(),
        duration: Date.now() - startTime,
        contractMetadata,
        networkInfo: await this.getNetworkInfo(request.networkId),
        vulnerabilities,
        gasOptimizations,
        complianceResults,
        summary,
        scannerVersion: '1.0.0',
        rulesVersion: '2024.1',
        confidence: this.calculateOverallConfidence(vulnerabilities),
        recommendations: this.generateRecommendations(vulnerabilities, gasOptimizations)
      };

      progressCallback?.(100, 'completed', 'Scan completed successfully!');
      return result;

    } catch (error: any) {
      if (error.name === 'AbortError') {
        throw error;
      }
      
      const vulnError = this.handleError(error);
      throw vulnError;
    }
  }

  private validateScanRequest(request: ScanRequest): void {
    if (!request.contractAddress) {
      throw new ValidationError('Contract address is required');
    }

    if (!request.contractAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
      throw new ValidationError('Invalid contract address format');
    }

    if (!request.networkId) {
      throw new ValidationError('Network ID is required');
    }

    const validScanTypes = ['quick', 'standard', 'deep'];
    if (!validScanTypes.includes(request.scanType)) {
      throw new ValidationError('Invalid scan type');
    }
  }

  private async checkRateLimit(): Promise<void> {
    try {
      const rateLimitInfo = await this.apiClient.getRateLimit();
      if (rateLimitInfo.remaining <= 0) {
        throw new RateLimitError('Rate limit exceeded', rateLimitInfo);
      }
    } catch (error: any) {
      if (error instanceof RateLimitError) {
        throw error;
      }
      // If rate limit check fails, continue (might be offline mode)
      console.warn('Rate limit check failed:', error.message);
    }
  }

  private async fetchContractMetadata(
    address: string,
    networkId: string,
    abortSignal?: AbortSignal
  ): Promise<ContractMetadata> {
    try {
      const response = await this.apiClient.get<ContractMetadata>(
        `/contracts/${address}/metadata`,
        { networkId },
        abortSignal
      );

      if (!response.success || !response.data) {
        throw new NetworkError('Failed to fetch contract metadata');
      }

      return response.data;
    } catch (error: any) {
      if (error.name === 'AbortError') {
        throw error;
      }
      throw new NetworkError(`Failed to fetch contract metadata: ${error.message}`);
    }
  }

  private async scanVulnerabilities(
    metadata: ContractMetadata,
    bytecodeAnalysis: any,
    scanType: string,
    abortSignal?: AbortSignal
  ): Promise<Vulnerability[]> {
    try {
      const response = await this.apiClient.post<Vulnerability[]>(
        '/scan/vulnerabilities',
        {
          metadata,
          bytecodeAnalysis,
          scanType
        },
        abortSignal
      );

      if (!response.success || !response.data) {
        throw new NetworkError('Vulnerability scan failed');
      }

      return response.data;
    } catch (error: any) {
      if (error.name === 'AbortError') {
        throw error;
      }
      
      // Fallback to local analysis if API fails
      console.warn('API vulnerability scan failed, using local analysis:', error.message);
      return this.contractAnalyzer.analyzeVulnerabilities(metadata, bytecodeAnalysis);
    }
  }

  private async analyzeGasOptimizations(
    metadata: ContractMetadata,
    bytecodeAnalysis: any,
    abortSignal?: AbortSignal
  ): Promise<GasOptimization[]> {
    try {
      const response = await this.apiClient.post<GasOptimization[]>(
        '/scan/gas-optimization',
        {
          metadata,
          bytecodeAnalysis
        },
        abortSignal
      );

      if (response.success && response.data) {
        return response.data;
      }
    } catch (error: any) {
      console.warn('API gas optimization failed, using local analysis:', error.message);
    }

    // Fallback to local analysis
    return this.contractAnalyzer.analyzeGasOptimizations(metadata, bytecodeAnalysis);
  }

  private async checkCompliance(
    metadata: ContractMetadata,
    bytecodeAnalysis: any,
    abortSignal?: AbortSignal
  ): Promise<ComplianceResult[]> {
    try {
      const response = await this.apiClient.post<ComplianceResult[]>(
        '/scan/compliance',
        {
          metadata,
          bytecodeAnalysis
        },
        abortSignal
      );

      if (response.success && response.data) {
        return response.data;
      }
    } catch (error: any) {
      console.warn('API compliance check failed, using local analysis:', error.message);
    }

    // Fallback to local analysis
    return this.contractAnalyzer.checkCompliance(metadata, bytecodeAnalysis);
  }

  private generateSummary(
    vulnerabilities: Vulnerability[],
    gasOptimizations: GasOptimization[],
    complianceResults: ComplianceResult[]
  ) {
    const criticalCount = vulnerabilities.filter(v => v.severity === 'Critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'High').length;
    const mediumCount = vulnerabilities.filter(v => v.severity === 'Medium').length;
    const lowCount = vulnerabilities.filter(v => v.severity === 'Low').length;
    const infoCount = vulnerabilities.filter(v => v.severity === 'Info').length;

    const overallRisk = criticalCount > 0 ? 'Critical' :
                       highCount > 0 ? 'High' :
                       mediumCount > 0 ? 'Medium' : 'Low';

    const riskScore = Math.max(0, 100 - (criticalCount * 25 + highCount * 15 + mediumCount * 10 + lowCount * 5));
    const gasOptimizationSavings = gasOptimizations.reduce((sum, opt) => sum + opt.savings, 0);
    const complianceScore = complianceResults.length > 0 
      ? complianceResults.reduce((sum, comp) => sum + comp.score, 0) / complianceResults.length 
      : 100;

    return {
      overallRisk,
      riskScore,
      totalVulnerabilities: vulnerabilities.length,
      criticalCount,
      highCount,
      mediumCount,
      lowCount,
      infoCount,
      gasOptimizationSavings,
      complianceScore
    };
  }

  private calculateOverallConfidence(vulnerabilities: Vulnerability[]): number {
    if (vulnerabilities.length === 0) return 95;
    
    const confidenceSum = vulnerabilities.reduce((sum, vuln) => {
      const confidenceValue = vuln.confidence === 'High' ? 90 : 
                             vuln.confidence === 'Medium' ? 70 : 50;
      return sum + confidenceValue;
    }, 0);
    
    return Math.round(confidenceSum / vulnerabilities.length);
  }

  private generateRecommendations(
    vulnerabilities: Vulnerability[],
    gasOptimizations: GasOptimization[]
  ): string[] {
    const recommendations: string[] = [];
    
    if (vulnerabilities.some(v => v.severity === 'Critical' || v.severity === 'High')) {
      recommendations.push('Address critical and high severity vulnerabilities immediately before deployment');
    }
    
    if (gasOptimizations.length > 0) {
      const totalSavings = gasOptimizations.reduce((sum, opt) => sum + opt.savings, 0);
      recommendations.push(`Consider implementing gas optimizations to save approximately ${totalSavings} gas per transaction`);
    }
    
    recommendations.push('Conduct regular security audits and keep dependencies updated');
    recommendations.push('Implement comprehensive testing including edge cases and attack scenarios');
    
    return recommendations;
  }

  private async getNetworkInfo(networkId: string) {
    // This would typically fetch from a configuration service
    const networks: { [key: string]: any } = {
      'ethereum': { id: 'ethereum', name: 'Ethereum Mainnet', chainId: 1, nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 } },
      'polygon': { id: 'polygon', name: 'Polygon', chainId: 137, nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 } },
      'bsc': { id: 'bsc', name: 'Binance Smart Chain', chainId: 56, nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 } }
    };
    
    return networks[networkId] || networks['ethereum'];
  }

  async exportResults(result: VulnerabilityScanResult, format: ExportFormat): Promise<void> {
    return this.reportGenerator.exportReport(result, format);
  }

  private handleError(error: any): VulnerabilityError {
    if (error instanceof VulnerabilityError) {
      return error;
    }
    
    if (error.code === 'NETWORK_ERROR' || error.name === 'NetworkError') {
      return new NetworkError(error.message, error);
    }
    
    return new VulnerabilityError(error.message || 'Unknown error occurred', 'UNKNOWN_ERROR', 500, error);
  }
}
