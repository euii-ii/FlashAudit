import { useState, useCallback, useRef } from 'react';
import { VulnerabilityService } from '../services/VulnerabilityService';
import { VulnerabilityScanResult, ScanRequest, ScanStatus } from '../types/vulnerability';

export interface UseVulnerabilityScannerReturn {
  // State
  isScanning: boolean;
  scanResults: VulnerabilityScanResult | null;
  scanHistory: VulnerabilityScanResult[];
  error: string | null;
  scanProgress: number;
  scanStatus: ScanStatus;
  
  // Actions
  startScan: (request: ScanRequest) => Promise<void>;
  cancelScan: () => void;
  clearResults: () => void;
  clearError: () => void;
  retryLastScan: () => Promise<void>;
  
  // Utilities
  getScanById: (scanId: string) => VulnerabilityScanResult | null;
  exportResults: (format: 'json' | 'pdf' | 'csv') => Promise<void>;
}

export const useVulnerabilityScanner = (): UseVulnerabilityScannerReturn => {
  const [isScanning, setIsScanning] = useState(false);
  const [scanResults, setScanResults] = useState<VulnerabilityScanResult | null>(null);
  const [scanHistory, setScanHistory] = useState<VulnerabilityScanResult[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [scanProgress, setScanProgress] = useState(0);
  const [scanStatus, setScanStatus] = useState<ScanStatus>('idle');
  
  const lastScanRequest = useRef<ScanRequest | null>(null);
  const currentScanController = useRef<AbortController | null>(null);
  const vulnerabilityService = useRef(new VulnerabilityService());

  const startScan = useCallback(async (request: ScanRequest) => {
    try {
      // Cancel any existing scan
      if (currentScanController.current) {
        currentScanController.current.abort();
      }

      // Create new abort controller
      currentScanController.current = new AbortController();
      
      // Reset state
      setError(null);
      setIsScanning(true);
      setScanProgress(0);
      setScanStatus('initializing');
      setScanResults(null);
      lastScanRequest.current = request;

      // Start the scan with progress tracking
      const result = await vulnerabilityService.current.performScan(
        request,
        currentScanController.current.signal,
        (progress: number, status: ScanStatus) => {
          setScanProgress(progress);
          setScanStatus(status);
        }
      );

      // Update results
      setScanResults(result);
      setScanHistory(prev => [result, ...prev.slice(0, 9)]); // Keep last 10 scans
      setScanStatus('completed');
      
    } catch (err: any) {
      if (err.name === 'AbortError') {
        setScanStatus('cancelled');
      } else {
        setError(err.message || 'Scan failed');
        setScanStatus('failed');
      }
    } finally {
      setIsScanning(false);
      setScanProgress(100);
      currentScanController.current = null;
    }
  }, []);

  const cancelScan = useCallback(() => {
    if (currentScanController.current) {
      currentScanController.current.abort();
      setScanStatus('cancelled');
      setIsScanning(false);
    }
  }, []);

  const clearResults = useCallback(() => {
    setScanResults(null);
    setScanProgress(0);
    setScanStatus('idle');
    setError(null);
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const retryLastScan = useCallback(async () => {
    if (lastScanRequest.current) {
      await startScan(lastScanRequest.current);
    }
  }, [startScan]);

  const getScanById = useCallback((scanId: string) => {
    return scanHistory.find(scan => scan.scanId === scanId) || null;
  }, [scanHistory]);

  const exportResults = useCallback(async (format: 'json' | 'pdf' | 'csv') => {
    if (!scanResults) {
      throw new Error('No scan results to export');
    }
    
    try {
      await vulnerabilityService.current.exportResults(scanResults, format);
    } catch (err: any) {
      setError(`Export failed: ${err.message}`);
      throw err;
    }
  }, [scanResults]);

  return {
    // State
    isScanning,
    scanResults,
    scanHistory,
    error,
    scanProgress,
    scanStatus,
    
    // Actions
    startScan,
    cancelScan,
    clearResults,
    clearError,
    retryLastScan,
    
    // Utilities
    getScanById,
    exportResults
  };
};

// Hook for managing scan configuration
export const useScanConfiguration = () => {
  const [config, setConfig] = useState({
    enableDeepScan: false,
    includeGasOptimization: true,
    includeComplianceCheck: true,
    scanTimeout: 300000, // 5 minutes
    maxConcurrentScans: 3
  });

  const updateConfig = useCallback((updates: Partial<typeof config>) => {
    setConfig(prev => ({ ...prev, ...updates }));
  }, []);

  return { config, updateConfig };
};

// Hook for managing network configurations
export const useNetworkConfig = () => {
  const [networks] = useState([
    { id: 'ethereum', name: 'Ethereum Mainnet', rpcUrl: 'https://mainnet.infura.io/v3/', chainId: 1 },
    { id: 'polygon', name: 'Polygon', rpcUrl: 'https://polygon-rpc.com/', chainId: 137 },
    { id: 'bsc', name: 'Binance Smart Chain', rpcUrl: 'https://bsc-dataseed.binance.org/', chainId: 56 },
    { id: 'arbitrum', name: 'Arbitrum', rpcUrl: 'https://arb1.arbitrum.io/rpc', chainId: 42161 },
    { id: 'optimism', name: 'Optimism', rpcUrl: 'https://mainnet.optimism.io/', chainId: 10 },
    { id: 'avalanche', name: 'Avalanche', rpcUrl: 'https://api.avax.network/ext/bc/C/rpc', chainId: 43114 },
    { id: 'fantom', name: 'Fantom', rpcUrl: 'https://rpc.ftm.tools/', chainId: 250 }
  ]);

  const getNetworkById = useCallback((id: string) => {
    return networks.find(network => network.id === id);
  }, [networks]);

  return { networks, getNetworkById };
};
